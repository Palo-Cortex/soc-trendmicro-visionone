commonfields:
  id: TrendMicroBuildEntitiesTableXSIAM
  version: -1
name: TrendMicroBuildEntitiesTableXSIAM
comment: Entities/IOC table. Reads incident fields; if empty, parses _alert_data.raw_json/impact_scope/observables for host/user/ip/hash/file/domain/url.
type: python
tags: [dynamic-section]
dockerimage: demisto/python3
enabled: true
fromversion: 6.2.0
marketplaces: [marketplacev2]
args:
  - name: hostnames_field
    defaultValue: entity_hostnames
  - name: hostips_field
    defaultValue: entity_host_ips
  - name: users_field
    defaultValue: entity_users
  - name: files_field
    defaultValue: entity_files
  - name: hashes_field
    defaultValue: entity_hashes
  - name: processes_field
    defaultValue: entity_processes
script: |-
  import json

  def get_val(src, key):
    if key in src and src.get(key): return src.get(key)
    cf = src.get('CustomFields') or src.get('customFields') or {}
    return cf.get(key)

  def norm_list(x):
    if not x: return []
    if isinstance(x, list):
      out=[]
      for v in x:
        s = v if isinstance(v, str) else str(v)
        s = s.strip().strip('"')
        if s: out.append(s)
      return out
    if isinstance(x, str):
      s=x.strip()
      if not s: return []
      try:
        o=json.loads(s)
        if isinstance(o, list):
          return [str(i).strip().strip('"') for i in o if str(i).strip().strip('"')]
      except Exception:
        pass
      for d in ['|', ',', ';', '\n', '\t', ' ']:
        if d in s:
          return [i.strip().strip('"') for i in s.split(d) if i.strip().strip('"')]
      return [s.strip().strip('"')]
    return [str(x)]

  def table_md(rows, headers):
    out=["| "+ " | ".join(headers) +" |","| "+ " | ".join(["---"]*len(headers)) +" |"]
    for r in rows:
      out.append("| "+ " | ".join(r) +" |")
    return "\n".join(out)

  def load_alert_json(inc):
    # prefer nested _alert_data.raw_json -> JSON
    for cand in ('_alert_data',):
      ad = inc.get(cand) or (inc.get('CustomFields',{}) or {}).get(cand)
      if isinstance(ad, dict):
        raw = ad.get('raw_json')
        if isinstance(raw, (dict,list)): return raw
        if isinstance(raw, str):
          for s in (raw, raw.replace('\\\"','\"')):
            try:
              return json.loads(s)
            except Exception:
              pass
    # fall back to raw_json at root/CF
    for cand in ('raw_json','rawJSON'):
      val = get_val(inc, cand)
      if isinstance(val,(dict,list)): return val
      if isinstance(val,str):
        for s in (val, val.replace('\\\"','\"')):
          try:
            return json.loads(s)
          except Exception:
            pass
    return None

  def walk_collect(obj, want):
    out = {k: set() for k in want}
    def _w(o):
      if isinstance(o, dict):
        for k,v in o.items():
          lk=k.lower()
          for w in want:
            if w in lk:
              if isinstance(v, (str,int,float)):
                out[w].add(str(v))
              elif isinstance(v, list):
                for it in v:
                  if isinstance(it,(str,int,float)): out[w].add(str(it))
          _w(v)
      elif isinstance(o, list):
        for it in o: _w(it)
    _w(obj)
    return {k: [s for s in sorted(v) if s] for k,v in out.items()}

  def main():
    inc=demisto.incidents()[0]
    args=demisto.args()

    hosts=norm_list(get_val(inc, args.get('hostnames_field','entity_hostnames')))
    ips  =norm_list(get_val(inc, args.get('hostips_field','entity_host_ips')))
    users=norm_list(get_val(inc, args.get('users_field','entity_users')))
    files=norm_list(get_val(inc, args.get('files_field','entity_files')))
    hashes=norm_list(get_val(inc, args.get('hashes_field','entity_hashes')))
    procs=norm_list(get_val(inc, args.get('processes_field','entity_processes')))

    need_more = not any([hosts, ips, users, files, hashes, procs])
    if need_more:
      aj = load_alert_json(inc)
      if aj:
        want = ['hostname','host','ip','sha256','sha1','hash','file','domain','url','user','username','process','cmdline','commandline']
        found = walk_collect(aj, want)

        hosts  = hosts  or found.get('hostname') or found.get('host') or []
        ips    = ips    or found.get('ip') or []
        users  = users  or found.get('username') or found.get('user') or []
        files  = files  or found.get('file') or []
        procs  = procs  or found.get('process') or []
        hashes = hashes or (found.get('sha256') or []) + (found.get('sha1') or []) or found.get('hash') or []
        domains = found.get('domain') or []
        urls    = found.get('url') or []
        files = files + domains + urls

    maxlen=max(len(hosts),len(ips),len(users),len(files),len(hashes),len(procs),1)
    def pad(lst): return lst+[""]*(maxlen-len(lst))
    rows=[]
    for i in range(maxlen):
      rows.append([pad(hosts)[i], pad(ips)[i], pad(users)[i], pad(files)[i], pad(hashes)[i], pad(procs)[i]])

    md=table_md(rows,["Hostname","IP","User","File/Domain/URL","Hash","Process"])
    demisto.results({'Type': entryTypes['note'], 'ContentsFormat': formats['markdown'], 'Contents': md})

  if __name__ in ('__main__','__builtin__','builtins'):
    main()
outputs: []
